---
title: 神经网络学习：从尝试识别手写数字开始
tags:
  - 神经网络
  - python
index_img: /img/v2-777808fc5b00e7727df4dc835c1fc44f_1440w.jpg
categories:
- [计算机, 知识整理]
- 值得一提的文章
notshow: false
date: 2023-04-24 04:53:00
excerpt: 神经网络入门笔记
---
# first
文章创建时间就很离谱：`2023-04-24 04:53:00`，晚上躺在床上感觉饿了，但是懒得下床买吃的，就一直饿的睡不着，终于在三点起床了下楼吃饱喝足了，回来毫无困意，于是开始写这篇离谱的文章
# 起点：分类任务
## 任务描述
已知四个数据点(1,1)(-1,1)(-1,-1)(1,-1)，这四个点分别对应I~IV象限，如果这时候给我们一个新的坐标点（比如(2,2)），那么它应该属于哪个象限呢？（当然是第I象限，但我们的任务是要让机器知道）

“分类”是神经网络的一大应用，我们使用神经网络完成这个分类任务。
## 网络结构：理论基础
我们构建一个两层神经网络，理论上两层神经网络已经可以拟合任意函数。这个神经网络的结构如下图：
![简化网络结构](v2-7ee8cabcbd707dd4deab7155af2ba4cd_1440w.webp)
### 正向传播
#### 输入层
在我们的例子中，输入层是坐标值，例如（1,1），这是一个包含两个元素的数组，也可以看作是一个1*2的矩阵。输入层的元素维度与输入量的特征相关，如果输入的是一张32*32的灰度图，那么输入层就是一个32*32的矩阵
#### 输入层到隐藏层
连接输入层和隐藏层的是W1和b1。由X计算得到H就是矩阵运算`H=X*W1+b1`。如上图中所示，在设定隐藏层为50维（也可以理解成50个神经元）之后，矩阵H的大小为（1*50）的矩阵
#### 隐藏层到输出层
连接隐藏层和输出层的是W2和b2。同样是通过矩阵运算`Y=X*W2+b2`
#### 激活层
通过上述两个线性方程的计算，我们就能得到最终的输出Y了，但是一系列线性方程的运算最终都可以用一个线性方程表示。也就是说，上述两个式子联立后可以用一个线性方程表达。对于两次神经网络是这样，就算网络深度加到100层，也依然是这样。这样的话神经网络就失去了意义。所以这里要对网络注入灵魂：激活层。

激活层是为矩阵运算的结果添加非线性的。常用的激活函数有三种，分别是阶跃函数、Sigmoid和ReLU。

|  ![](d000baa1cd11728b445e79fccbfcc3cec2fd2cf8.jfif) | ![](d009b3de9c82d158dfb4e7218a0a19d8bc3e426f.jfif)  |  ![](OIP-C.jfif) |
| :------------: | :------------: | :------------: |
| 阶跃函数  | Sigmoid  | ReLU  |
| 当输入小于等于0时，输出0；当输入大于0时，输出1  | 当输入趋近于正无穷/负无穷时，输出无限接近于1/0  | 当输入小于0时，输出0；当输入大于0时，输出等于输入  |

阶跃函数输出值是跳变的，且只有二值，较少使用；Sigmoid函数在当x的绝对值较大时，曲线的斜率变化很小（梯度消失），并且计算较复杂；ReLU是当前较为常用的激活函数。
每个隐藏层计算（矩阵线性运算）之后，都需要加一层激活层，要不然该层线性计算是没有意义的。

此时网络结构以及变成了：
![](v2-0ced86f32dfa241fc9de10421edbd9b4_1440w.webp)

#### 输出的正规化
在上一步之后，输出Y的值可能会是(3,1,0.1,0.5)这样的矩阵，诚然我们可以找到里边的最大值“3”，从而找到对应的分类为I，但是这并不直观。我们想让最终的输出为概率，也就是说可以生成像(90%,5%,2%,3%)这样的结果，这样做不仅可以找到最大概率的分类，而且可以知道各个分类计算的概率值。

计算公式如下：这样求出的结果中，所有元素的和一定为1，而每个元素可以代表概率值
![](v2-3ad93ae576918ff385485dab6a2e6b87_1440w.png)

我们将使用这个计算公式做输出结果正规化处理的层叫做“Softmax”层。此时的神经网络将变成如下图所示：
![](v2-01285f87ff9d523f62d2d4f6586583c5_1440w.webp)

#### 交叉熵损失（Cross Entropy Error）
比如，Softmax输出的结果是(90%,5%,3%,2%)，真实的结果是(100%,0,0,0)。虽然输出的结果可以正确分类，但是与真实结果之间是有差距的，一个优秀的网络对结果的预测要无限接近于100%，为此，我们需要将Softmax输出结果的好坏程度做一个“量化”。常用且巧妙的方法是，求对数的负数。用90%举例，对数的负数就是：-log0.9=0.046

概率越接近100%，该计算结果值越接近于0，说明结果越准确，该输出叫做`交叉熵损失`。我们训练神经网络的目的，就是尽可能地减少这个损失。

此时的网络如下图：
![](v2-6fac69d2abab24639943ebaab0b70bde_1440w.webp)

### 反向传播
反向传播就是一个参数优化的过程，优化对象就是网络中的所有W和b。神经网络的神奇之处，就在于它可以自动做W和b的优化。使用的方法叫做梯度下降法
### 迭代
神经网络需要反复迭代。如上述例子中，第一次计算得到的概率是90%，交叉熵损失值是0.046；将该损失值反向传播，使W1,b1,W2,b2做相应微调；再做第二次运算，此时的概率可能就会提高到92%，相应地，损失值也会下降，然后再反向传播损失值，微调参数W1,b1,W2,b2。依次类推，损失值越来越小，直到我们满意为止。此时我们就得到了理想的W1,b1,W2,b2。

此时如果将任意一组坐标作为输入，利用图4或图5的流程，就能得到分类结果。
## 网络实现：使用python实现分类功能
### 前置任务
导入numpy库
```
import numpy as np
```
### 正向传播函数


# 参考资料
https://zhuanlan.zhihu.com/p/65472471
https://zhuanlan.zhihu.com/p/67682601
https://zhuanlan.zhihu.com/p/66534632